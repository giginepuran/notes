# Chapter2 陣列結構

## 2-1 線性串列簡介
線性串列(Linear List)是一種相當基本的資料結構, 常見的陣列結構(Array)就是一種典型線性串列的應用.

### 儲存結構簡介
按照記憶體儲存的方式可區分為:
- 靜態資料結構 (Static Data Structure)
靜態資料結構又稱為**密集串列**(Dense List), 將有序串列的資料使用**連續的記憶體空間**(Contiguous Allocation)來儲存.
靜態的資料結構會在編譯時便將記憶體配置給相關的變數, 因此必須一開始就宣告好記憶體的大小, 容易造成記憶體的浪費, 而陣列(Array)就是一種靜態的資料結構.
-- 優點: 設計時簡單, 讀寫陣列中任一元素的時間都固定
-- 缺點: 刪除或加入資料時, 需要移動大量資料

- 動態資料結構 (Dynamic Data Structure)
動態資料結構又稱為鏈結串列(**Linked List**), 將現性串列的資料**以不連續的記憶體來儲存**.
-- 優點: 程式執行時才配置記憶體, 充分利用記憶體, 修改方便.
-- 缺點: 設計資料結構時較麻煩, 搜索資料時必須循序的找.


## 2-2 認識陣列
陣列(Array)結構就是一排緊密相連的可數記憶體, 因為緊密相連所以可提供一個直接存取單一資料的計算方法, 不必像動態資料結構般要循序的查找.

舉例來說, 程式語言中陣列的**名稱**是表示一塊相連記憶體區塊的**起始位置**, 而陣列的索引(index)讓我們可直接算出要找的資料是在起始位置後第幾個區塊.

不同語言的陣列結構的**型態宣告**會有所差異, 不過通常都包含下列五種屬性:
```csvpreview
起始位置, 表陣列名稱或陣列第一個元素所在記憶體位置
維度, 例如一維陣列 二維陣列 三維陣列...
索引上下限, 元素在陣列中記憶體位置的上下標
陣列元素個數, 索引上下限差值+1
陣列型態, 決定陣列中資料的型態及需要多少的記憶體
```
即便是多維陣列, 在記憶體中儲存的方式仍是線性連續的, 
故維度就會影響到查找陣列中資料的方式.
多維陣列儲存方式又分為以列(row)/以行(column)為主.

### 一維陣列
在C#中int需用32個位元(bit), 即4個位元組(Byte)來儲存.
故當我們宣告一個大小為十的int array時
```csharp
int[] arr = new int[10]; 
```
arr這個陣列的在記憶體中的大小就為 4*10 = 40 Bytes.

#### 一維陣列練習:
Q: A為一具有1000個元素的陣列, 每個元素大小為4 Bytes, 若A[500]的位置為$1000_{16}$, 請問A[1000]的位置為何?

ANS: A[1000]與A[500]間隔了500\*4個Bytes, 又**位元組是記憶體容量儲存的基本單位**, 故兩者差了2000個記憶體位置.
A[1000]位置為$1000_{16}+2000_{10}=6096_{10}=\text{17D0}_{16}$

### 二為陣列
以5x4 2D array為例, 其資料位置對應的index如下圖
![2d_array](https://imgur.com/4H7YgUN.jpg)
則row/column-major形式, 將資料存在記憶體中順序如下
![rowcol](https://imgur.com/DAhmi6v.jpg)
![inMemory](https://imgur.com/8I8V5fH.jpg)

#### 二維陣列練習:
Q1: 有一3x5二維陣列A(,), 陣列起始位置A(0,0)為100,
且其為row-major, 每個元素2 Bytes, 請問A(1,2)的位置?

ANS1:
row的差距為+1, column的差距為+2, 因為是row-major
故間個資料數為 (+1) * 5(column數) + (+2) = 7個資料.
=> A(1,2)的位置為100+7\*2=114.

Q2: 有一5x6二維陣列A(,), 且其為column-major, 請問A(3,4)是為於此陣列中第幾個資料?

ANS2:
問第幾個, 故以A(0,0)當起點, row的差距為+3, column的差距為+4, 因為是column-major
故間個資料數為 (+4) * 5(row數) + (+3) = 27個資料.
=> A(3,4)是第28個資料 
(參考書[1]應該是錯的)

### 三維陣列
懶的畫圖, 直接想像現有一個 mxnxo 的三維陣列A,

- 若是row-major: 
mxnxo = mx(nxo), **再將(nxo)看作2D row-major array**, 照row-major的邏輯, **相同row的會先被放進記憶體**, 故其資料排列為:
A(0,0,0) -> A(0,0,1) -> A(0,0,2) ... -> A(0,0,o-1) ->
A(0,1,0) -> A(0,1,1) -> A(0,1,2) ... -> A(0,1,o-1) ->
... -> A(0,n-1,o-1) ->
以上是mx(nxo)中同為0-m_row的排列
之後就接A(1,0,0)以次類推.

- 若是column-major:
mxnxo = (mxn)xo, **再將(mxn)看作2D column-major array**, 之後邏輯同上, 故其資料排列為:
A(0,0,0) -> A(1,0,0) -> ... -> A(m-1,0,0) ->
... -> A(m-1,n-1,0) ->
A(0,0,1) -> ...

更高維的Array也是同邏輯.

#### 三維陣列練習:
Q1: 現有row-major的3x4x5 3D array, 已知A(0,0,0)位於100, 資料大小是1 Byte, 請問A(0,1,2)位於?

ANS1:
維度差分別為 0,+1,+2且其為row-major, 故從第一個維度開始計算, 距離 
0 * (4\*5)(第一個column數) + 1 * 5(第二個column數) + 2 = 7個資料
故A(0,1,2)位於100+7\*1=107的記憶體位置

Q2: 現有column-major的6x4x2 3D array, 已知A(0,0,0)位於300, 資料大小是1 Byte, 請問A(3,3,0)位於?

ANS2:
維度差分別為 +3,+3,0且其為column-major, 故從最後一個維度開始計算, 距離
0 * (6\*4) + 3 * 6 + 3 = 21個資料
故A(3,3,0)位於300+21\*1=321的記憶體位置
(哭阿參考書[1]怎麼又給錯答案了= =)

## 2-3 矩陣
GPU是以向量和矩陣運算為基礎, 配合平行運算, 可以拿來做超大矩陣的運算. (不曉得向量運算的硬體結構到底長怎樣)
###### 用陣列來做矩陣運算全部跳過

### 稀疏矩陣 (sparse matrix)
很多元素是0的矩陣便可稱為稀疏矩陣, 若我們仍用相同大小的陣列去儲存會顯得非常浪費空間, 我們可以只儲存非0的資料, 即其在稀疏矩陣中的位置即可.

想像現有一個大小為$a_1\times a_2\times ... \times a_N$的N維的稀疏矩陣, 其內部共有M個非零元素. 若用等大小的陣列儲存, 我們會需要$a_1\times a_2\times ... \times a_N\times\text{Size of Data}$ 的空間.

但若我們只儲存非0的M個元素, 及各個元素N維的資訊, 
則我們變成只需要$M\times (N+1)$的空間來儲存這個矩陣的所有資訊, 這種作法稱為壓縮矩陣.

# 好像壓縮的方式有很多種, 研究中 看懂了再繼續

##### 心得及其他
1. 123

## 參考資料
[1] 吳燦銘, 胡昭民, 圖解資料結構 使用C#

###### tags: `note` `圖解資料結構筆記`